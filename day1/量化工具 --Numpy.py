"""
Numpy是python很多科学计算与工程库的基础库，在量化数据分析中最常使用的Pandas
也是基于Numpy的封装。可以说Numpy就是量化数据分析领域中的基础数组，学会使用Numpy
是量化分析中关键的一步

Numpy底层实现中使用了C语言和Fortran语言的机制分配内存。可以理解为它的输出是一个非常大且
联系的并且由同类型数据组成的内存区域，所以可以通过Numpy来构造一个比普通列表大的多的数组，并且
灵活高效地对数组中所有的元素进行并行化操作
"""

import timeit
import time
import numpy as np

"""
使用timeit模块来计算构建10000个元素的列表循环求每个元素的平方所用的时间
timeit模块使用方法 timeit(stmt,number)
stmt可以直接传简单的字符串表达式，也可以传变量，也可以传函数，接受匿名函数输入
"""

#1、使用普通方法构造列表
func1 = """
for i in range(10000):
    i**2
"""
print(timeit.timeit(stmt=func1,number=1))

#结果：0.003410174186735481
"""
或者在jupyternotebook中执行
normal_list = range(10000)
%timeit [i**2 for i in normal_list]
得到的时间为：
3.67 ms ± 67.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
"""

#2、使用numpy的arange模块来构造列表

"""
在jupyternotebook中执行下面代码，
np_list = np.arange(10000)
%timeit (np_list**2)
得到的时间为：
9.22 µs ± 24 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)


可以看到使用numpy数组的速度远快于使用普通列表的速度
Numpy数组和普通列表的操作方式也是不同的，Numpy通过广播机制作用于每一个内部元素，是一种
并行化执行的思想，普通list则作用于整体，示例如下：
"""

#注意：在numpy中*3的操作被作用于数组的每一个元素中
np_list = np.ones(5) * 3
print(np_list)
# [3. 3. 3. 3. 3.]

#普通列表则把*3操作认为是整体性操作
normal_list = [1,1,1,1,1] * 3
print(normal_list)
# <class 'list'>: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
print(len(normal_list))
# 15

#numpy的初始化操作

"""
一些numpy常用的初始化方式
"""

#1、100个0
np.zeros(100)
# array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])


#2、shape: 3行2列全是0
np.zeros((3,2))
# array([[0., 0.],
#        [0., 0.],
#        [0., 0.]])

#3、shape:3行2列全是1
np.ones((3,2))
# array([[1., 1.],
#        [1., 1.],
#        [1., 1.]])

#4、shape:x=2,y=3,z=3 值随机
np.empty((2,3,3))
#生成两个3行3列的矩阵
# array([[[0.00000000e+000, 1.54203400e-311, 0.00000000e+000],
#         [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],
#         [0.00000000e+000, 1.54205718e-311, 1.54205718e-311]],
#        [[1.54205718e-311, 1.54205718e-311, 0.00000000e+000],
#         [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],
#         [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]]])

#5、初始化序列与np_list一样的shape，值权为1
# np_list = [3. 3. 3. 3. 3.]
np.ones_like(np_list)
# array([1., 1., 1., 1., 1.])

#6、初始化序列与np_list一样的shape，值全为0
# np_list = [3. 3. 3. 3. 3.]
np.zeros_like(np_list)
# array([0., 0., 0., 0., 0.])

#7、得到对角线全为1的单位矩阵
np.eye(3)
# array([[1., 0., 0.],
#        [0., 1., 0.],
#        [0., 0., 1.]])

#8、通过普通列表用np.array方法来初始化得到np array
data = [[1,2,3,4],[5,6,7,8]]
arr_np = np.array(data)
# array([[1, 2, 3, 4],
#        [5, 6, 7, 8]])

#9、通过linspace()来在0~1之间等间隔生成10个元素的序列
np.linspace(0,1,10)
# array([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
#        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])
