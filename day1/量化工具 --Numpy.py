"""
Numpy是python很多科学计算与工程库的基础库，在量化数据分析中最常使用的Pandas
也是基于Numpy的封装。可以说Numpy就是量化数据分析领域中的基础数组，学会使用Numpy
是量化分析中关键的一步

Numpy底层实现中使用了C语言和Fortran语言的机制分配内存。可以理解为它的输出是一个非常大且
联系的并且由同类型数据组成的内存区域，所以可以通过Numpy来构造一个比普通列表大的多的数组，并且
灵活高效地对数组中所有的元素进行并行化操作
"""

import timeit
import time
import numpy as np

"""
使用timeit模块来计算构建10000个元素的列表循环求每个元素的平方所用的时间
timeit模块使用方法 timeit(stmt,number)
stmt可以直接传简单的字符串表达式，也可以传变量，也可以传函数，接受匿名函数输入
"""

'#######################################################################################################################'

#1、使用普通方法构造列表
func1 = """
for i in range(10000):
    i**2
"""
print(timeit.timeit(stmt=func1,number=1))

#结果：0.003410174186735481
"""
或者在jupyternotebook中执行
normal_list = range(10000)
%timeit [i**2 for i in normal_list]
得到的时间为：
3.67 ms ± 67.1 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)
"""

#2、使用numpy的arange模块来构造列表

"""
在jupyternotebook中执行下面代码，
np_list = np.arange(10000)
%timeit (np_list**2)
得到的时间为：
9.22 µs ± 24 ns per loop (mean ± std. dev. of 7 runs, 100000 loops each)


可以看到使用numpy数组的速度远快于使用普通列表的速度
Numpy数组和普通列表的操作方式也是不同的，Numpy通过广播机制作用于每一个内部元素，是一种
并行化执行的思想，普通list则作用于整体，示例如下：
"""

#注意：在numpy中*3的操作被作用于数组的每一个元素中
np_list = np.ones(5) * 3
print(np_list)
# [3. 3. 3. 3. 3.]

#普通列表则把*3操作认为是整体性操作
normal_list = [1,1,1,1,1] * 3
print(normal_list)
# <class 'list'>: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
print(len(normal_list))
# 15

'#######################################################################################################################'

#numpy的初始化操作

"""
一些numpy常用的初始化方式
"""

#1、100个0
np.zeros(100)
# array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
#        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])


#2、shape: 3行2列全是0
np.zeros((3,2))
# array([[0., 0.],
#        [0., 0.],
#        [0., 0.]])

#3、shape:3行2列全是1
np.ones((3,2))
# array([[1., 1.],
#        [1., 1.],
#        [1., 1.]])

#4、shape:x=2,y=3,z=3 值随机
np.empty((2,3,3))
#生成两个3行3列的矩阵
# array([[[0.00000000e+000, 1.54203400e-311, 0.00000000e+000],
#         [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],
#         [0.00000000e+000, 1.54205718e-311, 1.54205718e-311]],
#        [[1.54205718e-311, 1.54205718e-311, 0.00000000e+000],
#         [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],
#         [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]]])

#5、初始化序列与np_list一样的shape，值权为1
# np_list = [3. 3. 3. 3. 3.]
np.ones_like(np_list)
# array([1., 1., 1., 1., 1.])

#6、初始化序列与np_list一样的shape，值全为0
# np_list = [3. 3. 3. 3. 3.]
np.zeros_like(np_list)
# array([0., 0., 0., 0., 0.])

#7、得到对角线全为1的单位矩阵
np.eye(3)
# array([[1., 0., 0.],
#        [0., 1., 0.],
#        [0., 0., 1.]])

#8、通过普通列表用np.array方法来初始化得到np array
data = [[1,2,3,4],[5,6,7,8]]
arr_np = np.array(data)
# array([[1, 2, 3, 4],
#        [5, 6, 7, 8]])

#9、通过linspace()来在0~1之间等间隔生成10个元素的序列
np.linspace(0,1,10)
# array([0.        , 0.11111111, 0.22222222, 0.33333333, 0.44444444,
#        0.55555556, 0.66666667, 0.77777778, 0.88888889, 1.        ])

'#######################################################################################################################'


"""
一个例子：通过np.random.standard_normal()随机生成200支股票504个交易日服从正态分布的涨跌幅数据
$两年美股交易日总数 252*2 = 504
$交易日的数量越多，股票的数量越多，生成的数据越服从正态分布
"""

#200只股票
stock_count = 200

#504个交易日
view_days = 504

#生成正态分布：均值期望 = 0,标准差 = 1的序列
stock_day_change = np.random.standard_normal((stock_count,view_days))

#打印shape(200,504) 200行 504列
print(stock_day_change.shape)
# (200, 504)

#打印第一只股票，前5个交易日的涨跌幅情况
print (stock_day_change[0:1, :5])
# [[ 0.76926566  0.26202816  1.09951781  0.41148683 -1.38644049]]

'#######################################################################################################################'

"""
经过上面的操作后，可以得到结果为200行504列的矩阵，每一行代表一只股票，每一列代表一个交易日的涨跌幅。
"""

"""
数据的转换与规整
数据进行类型转换的目的，有些时候是为了规整数据，有些时候可以通过类型转换进一步得到有用的信息。以下代码使用astype(int)将
涨跌幅转换为int后的结果，可以更清晰的发现涨跌幅数据两端的极限值，示例如下：
"""

print(stock_day_change[0:2,0:5])
print(stock_day_change[0:2,0:5].astype(int))

#输出如下：
# [[-1.16127774  0.88150936  1.00535831  0.14685506 -1.25436484]
#  [ 0.40657144  0.48875463 -1.48877665  0.48752567 -0.7245854 ]]
# [[-1  0  1  0 -1]
#  [ 0  0 -1  0  0]]
# 如果只是想要规整float的数据，如果保留两位小数，可以使用np.around()函数，示例如下：

#保留2位小数
np.around(stock_day_change[0:2,0:5],2)

# 输出如下：
# array([[-1.16,  0.88,  1.01,  0.15, -1.25],
#        [ 0.41,  0.49, -1.49,  0.49, -0.72]])

# 很多时候需要处理的数据会有缺失，numpy中np.nan代表缺失，这里手工使切片中的第一元素变为na，代码如下：

#使用copy()函数的目的是不修改原始序列
tmp_test = stock_day_change[0:2,0:5].copy()

#将第一个元素改成nan
tmp_test[0][0] = np.nan
print(tmp_test)
# [[        nan  0.88150936  1.00535831  0.14685506 -1.25436484]
#  [ 0.40657144  0.48875463 -1.48877665  0.48752567 -0.7245854 ]]

#使用np.nan_to_num()函数来用0来填充na，由于pandas中的dropna()和fillna()等方式更适合处理nan，示例如下
tmp_test = np.nan_to_num(tmp_test)
print(tmp_test)
# [[ 0.          0.88150936  1.00535831  0.14685506 -1.25436484]
#  [ 0.40657144  0.48875463 -1.48877665  0.48752567 -0.7245854 ]]

'#######################################################################################################################'

"""
逻辑条件进行数据筛选
"""

#找出切片内涨幅超过0.5的股票时段，通过输出结果可以看到返回的mask是bool的数组，示例如下

mask = stock_day_change[0:2,0:5] > 0.5
print(mask)
# [[False  True  True False False]
#  [False False False False False]]

# mask的使用方法：
print(tmp_test[mask])
# array([0.88150936, 1.00535831])

# 其他使用方法
tmp_test = stock_day_change[-2:,-5:]
print(tmp_test[(tmp_test>1) | (tmp_test<-1)])
# [-1.22873737  2.07497224]

tmp_test[(tmp_test>1) | (tmp_test<-1)] = 1
print(tmp_test)
# [[-0.4053339   0.25982894  0.3546099  -0.62828459  0.21791254]
#  [ 1.          1.          0.24547128 -0.34095098 -0.17635608]]

'#######################################################################################################################'
"""
通用序列函数
"""


'#######################################################################################################################'

"""
基础统计概念与函数使用
量化中很多技术手段都是基于统计技术实现的，Numpy给python带来的不仅只有序列化并行执行的思想，更有统计学上很多方法的实现，比如期望(np.mean())、
方差(np.var())、标准差(np.std())等，下面说明一些Numpy中使用的统计相关的函数


"""
stock_day_change_four = stock_day_change[:4,:4]
print(stock_day_change_four)
# [[-1.16127774  0.88150936  1.00535831  0.14685506]
#  [ 0.40657144  0.48875463 -1.48877665  0.48752567]
#  [-1.50655395 -1.7205798  -1.03894972  1.27652508]
#  [-0.94481997  1.62701559  1.83180435 -0.23140463]]

#axis = 1 为行向比较 axis = 0为列向比较
print('最大涨幅{}'.format(np.max(stock_day_change_four,axis=1)))
# 最大涨幅[1.00535831 0.48875463 1.27652508 1.83180435]

'#######################################################################################################################'
"""
基础统计概念：
1、期望：试验中每次可能结果的概率乘以其结果的总和，反映一组数据平均取值的大小，用于表示分布的中心位置
2、方差：在概率论和统计学中，方差是衡量一组数据离散程度的度量，概率论中方差用来度量数据和其期望之间的离散程度，方差越大，说明数据越离散
3、标准差：标准差是方差的平方根，标准差和变量的计算单位相同，所以比其测得的误差结果比方差清晰，因此很多时候分析离散程度更多的使用标准差

"""